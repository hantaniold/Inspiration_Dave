//  Parse.com bridge for Playtomic Flash users// -------------------------------------------------------------------------//  Note:  This requires a Playtomic.com account AND a Parse.com account,//  you will have to register at Parse and configure the settings in your//  Playtomic dashboard.////  http://parse.com/////  If you are using Objective C or Android you should use the official//  Parse SDKs available directly through Parse.com.////// -------------------------------------------------------------------------//  This file is part of the official Playtomic API for ActionScript 3 games.  //  Playtomic is a real time analytics platform for casual games //  and services that go in casual games.  If you haven't used it //  before check it out://  http://playtomic.com/////  Created by ben at the above domain on 2/25/11.//  Copyright 2011 Playtomic LLC. All rights reserved.////  Documentation is available at://  http://playtomic.com/api/as3//// PLEASE NOTE:// You may modify this SDK if you wish but be kind to our servers.  Be// careful about modifying the analytics stuff as it may give you // borked reports.//// If you make any awesome improvements feel free to let us know!//// -------------------------------------------------------------------------// THIS SOFTWARE IS PROVIDED BY PLAYTOMIC, LLC "AS IS" AND ANY// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.package Playtomic{	public final class Parse 	{		private static var SECTION:String;		private static var SAVE:String;		private static var DELETE:String;		private static var LOAD:String;		private static var FIND:String;				internal static function Initialise(apikey:String):void		{			SECTION = Encode.MD5("parse-" + apikey);			SAVE = Encode.MD5("parse-save-" + apikey);			DELETE = Encode.MD5("parse-delete-" + apikey);			LOAD = Encode.MD5("parse-load-" + apikey);			FIND = Encode.MD5("parse-find-" + apikey);		}						/**		 * Creates or updates an object in your Parse.com database		 * @param	pobject		A ParseObject, if it has an objectId it will update otherwise save		 * @param	callback	Callback function to receive the data:  function(pobject:ParseObject, response:Response)		 */		public static function Save(pobject:PFObject, callback:Function = null):void		{			PRequest.Load(SECTION, SAVE, SaveComplete, callback, ObjectPostData(pobject));		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function SaveComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;							var obj:XMLList = data["object"];			var item:XML = obj[0];						var pobject:PFObject = new PFObject();			pobject.ObjectId = item["id"];			pobject.ClassName = postdata["classname"];			pobject.Password = postdata["password"];									for(var key:String in postdata)			{				if(key.indexOf("data") == 0)				{										pobject.Data[key.substring(4)] = postdata[key];				}			}						if(response.Success)			{				var object:XMLList = data["object"];				pobject.CreatedAt = DateParse(object["created"]);				pobject.UpdatedAt = DateParse(object["created"]);			}						callback(pobject, response);		}				/**		 * Deletes an object in your Parse.com database		 * @param	pobject		A ParseObject that must include the ObjectId		 * @param	callback	Callback function to receive the data:  function(response:Response)		 */		public static function Delete(pobject:PFObject, callback:Function = null):void		{			PRequest.Load(SECTION, DELETE, DeleteComplete, callback, ObjectPostData(pobject));		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function DeleteComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;			callback(response);			data = data; // just to hide unused var warning			postdata = postdata;		}				/**		 * Loads a specific object from your Parse.com database		 * @param	pobject		A ParseObject that must include the ObjectId and className		 * @param	callback	Callback function to receive the data:  function(pobject:ParseObject, response:Response)		 */		public static function Load(pobjectid:String, classname:String, callback:Function = null):void		{			var pobject:PFObject = new PFObject();			pobject.ObjectId = pobjectid;			pobject.ClassName = classname;						PRequest.Load(SECTION, LOAD, LoadComplete, callback, ObjectPostData(pobject));		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function LoadComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;							var pobject:PFObject = new PFObject();			pobject.ObjectId = postdata["objectid"];			pobject.ClassName = postdata["classname"];							if(response.Success)			{				var object:XMLList = data["object"];				pobject.CreatedAt = DateParse(object["created"]);				pobject.UpdatedAt = DateParse(object["updated"]);								if(object.contains("fields"))				{					var fields:XMLList = object["fields"];										for each(var field:XML in fields.children())					{						pobject[field.name] = field.text();					}				}			}						callback(pobject, response);		}				/**		 * Finds objects matching the criteria in your ParseQuery		 * @param	pquery		A ParseQuery object		 * @param	callback	Callback function to receive the data:  function(objects:Array, response:Response)		 */		public static function Find(pquery:PFQuery, callback:Function = null):void		{			var postdata:Object = new Object();			postdata["classname"] = pquery.ClassName;			postdata["limit"] = pquery.Limit;			postdata["order"] = pquery.Order != null && pquery.Order != "" ? pquery.Order : "created_at";						for(var key:String in pquery.WhereData)			{				postdata["data" + key] = pquery.WhereData[key];			}						PRequest.Load(SECTION, FIND, FindComplete, callback, postdata);		}				/**		 * Processes the response received from the server, returns the data and response to the user's callback		 * @param	callback	The user's callback function		 * @param	postdata	The data that was posted		 * @param	data		The XML returned from the server		 * @param	response	The response from the server		 */		private static function FindComplete(callback:Function, postdata:Object, data:XML = null, response:Response = null):void		{			if(callback == null)				return;							var objs:Array = new Array();						if(response.Success)			{				var objects:XMLList = data["objects"];								for each(var object:XML in objects.children())				{									var pobject:PFObject = new PFObject();					pobject.ObjectId = object["id"];					pobject.CreatedAt = DateParse(object["created"]);					pobject.UpdatedAt = DateParse(object["updated"]);										if(object.contains("fields"))					{						var fields:XMLList = object["fields"];												for each(var field:XML in fields.children())						{							pobject[field.name] = field.text();						}					}														objs.push(pobject);				}			}						callback(objs, response);			postdata = postdata;		}					/**		 * Turns a ParseObject into data to be POST'd for saving, finding 		 * @param	pobject		The ParseObject		 */			private static function ObjectPostData(pobject:PFObject):Object		{			var postobject:Object = new Object();			postobject["classname"] = pobject.ClassName;			postobject["id"] = (pobject.ObjectId == null ? "" : pobject.ObjectId);			postobject["password"] = (pobject.Password == null ? "" : pobject.Password);						for(var key:String in pobject.Data)				postobject["data" + key] = pobject.Data[key];							return postobject;		}				/**		 * Converts the server's MM/dd/yyyy hh:mm:ss into a Flash Date		 * @param	date		The date from the XML		 */			private static function DateParse(date:String):Date		{			var parts:Array = date.split(" ");			var dateparts:Array = (parts[0] as String).split("/");			var timeparts:Array = (parts[1] as String).split(":");			var day:int = int(dateparts[1]);			var month:int = int(dateparts[0]);			var year:int = int(dateparts[2]);			var hours:int = int(timeparts[0]);			var minutes:int = int(timeparts[1]);			var seconds:int = int(timeparts[2]);			return new Date(Date.UTC(year, month, day, hours, minutes, seconds));		}	}}